% describe the modification of the Impact algorithm for heaps

% describe the standard Impact algorithm
% \section{Heap Impact Algorithm}
\label{ch:heap-impact-algorithm}
%

Building on top of the framework defined in \autoref{sec:impact-algorithm} and \autoref{ch:heap-patterns}, we can define \verifier, by modifying the \impact algorithm to work for heap-manipulating programs. In this chapter, we first define the three steps of \impact, that is \expand, \cover, and \refine for \verifier, respectively calling them \expandp, \coverp, and \refinep. Then we describe an interpolant-learning procedure that retrieves patterns from an Oracle, thereby completing the description of the algorithm.

\section{Notation Review}
In this section, we briefly go over some of the notation from previous chapters that will be relevant to the description of \verifier.

\subsection{Programs}
Recall that a \textit{program} is a tuple $(\Lambda, \Delta, l_i, l_f)$, where $\Lambda$ is a finite set of program locations, $\Delta$ is a set of $actions$, $l_i \in \Lambda$ is the initial location and $l_f \in \Lambda$ is the error location. An $action$ is a triple $(l, T, m)$, where $l,m \in \Lambda$ are respectively the entry and exit locations of the action, and $G$ is a transition formula.

\subsection{Program Paths}
A $path$ $\pi$ of a program is a sequence of transitions of the form $(l_0, T_0, l_1)(l_1, T_1, l_2) \cdots (l_{n-1}, T_{n-1}, l_n)$. The path is an \textit{error path} when $l_0 = l_1$ and $l_n = l_f$. The unfolding $\mathcal{U}(\pi)$ of path $\pi$ is the sequence of formulas $T_0^{\langle 0 \rangle}, \cdots, T_{n-1}^{\langle n-1 \rangle}$, that is, the sequence of transition formulas $T_0, \cdots, T_{n-1}$, with each $T_i$ shifted $i$ time units into the future.

For further details, the reader is referred to \autoref{sec:modeling-programs}.

\subsection{Program Unwindings}
As defined in \autoref{defn:prog-unwinding}, an unwinding of a program $\mathcal{A} = (\Lambda, \Delta, l_i, l_f)$ is a quadruple $(V, E, M_v, M_e)$, where $(V, E)$ is a directed tree rooted at $\epsilon$, $M_v : V \rightarrow \Lambda$ is the vertex map, and $M_e : E \rightarrow \Delta$ is the edge map, such that $M_v(\epsilon) = l_i$. Also, for every non-leaf vertex $v \in V$, for every action $(M_v(v), T, m) \in \Delta$, there exists an edge $(v,w) \in E$ such that $M_v(w) = m$ and $M_e(v,w) = T$. Intuitively, an unwinding is a tree where each vertex is mapped ($M_v$) to a program location, and each edge is mapped ($M_e$) to a step (action) in the program.

As defined in \autoref{defn:labeled-heap-prog-unwinding}, a labeled unwinding of a program $\mathcal{A} = (\Lambda, \Delta, l_i, l_f)$ is a triple $(U, \psi, \rhd)$, where $U = (V, E, M_v, M_e)$ is an unwinding of $\mathcal{A}$, $\psi : V \to \heappats$ is called the vertex labeling, and $\rhd \subseteq V \times V$ is the covering relation. Intuitively, a labeled unwinding is a program unwinding where each vertex is labeled ($\psi$) with a heap pattern, and a covering relation $\rhd$ is used, which is used to keep track of covered vertices that need not be explored further.

\subsection{Postcondition Transforms for Heap Operations}
In addition to the previous definitions, we define the operator $\post$, which will be used for generating examples to interact with the Oracle. $\post$ is an operator for computing strongest postconditions for heap patterns modified by \lang instructions.

% define labeled program unwinding
\begin{defn}
  \label{defn:heap-post-transforms}
  The operator $\post$, which computes the strongest postcondition for a given heap pattern, and action. That is $\post : \heappats \times \mathcal{T} \to \heappats$, where $\mathcal{T}$ is the set of all actions.

  The $\post{*}$ operator can be defined as a repeated application of $\post$ along a given path. More formally, it is $\post{*} : \heappats \times \mathcal{P} \to \heappats$, where $\mathcal{P}$ is a path in the unwinding.
\end{defn}

We also note that the $\post$ operator can be overloaded to work with individual heaps instead of patterns, since single heaps can also be represented using a pattern.

The formal rules for computing $\post$ for each individual action are presented here. We define them for major heap operations that are part of \lang. The formal requirement is that for a heap $h$, pattern $P$, and transition $T$, such that $h \matchedby P$, we must have $\post(h, T) \matchedby \post(P, T)$. Assume that the original pattern is represented by $P = (\nodesnm, \varlblnm, \predlblnm, \edgesnm, \sigma)$, and the pattern after transformation by $\post$ is represented by $P' = (\nodesnm', \varlblnm', \predlblnm', \edgesnm', \sigma')$. We define $P'$ using the definition of $P$, for each possible value of $T$ below. New variables are presented as updates to the values of old variables.

\begin{itemize}
  \item \textbf{ALLOC} ($v := alloc()$): \\
    - $\nodesnm' = \nodesnm \cup \{n\}$ where $n \not \in \nodesnm$ is a new node allocated by $alloc()$ \\
    - $\varlblnm'$ updates $\varlblnm$ such that $\varlblnm'(n, v) = \true$ and $\forall m \neq n, \varlblnm'(m, v) = \false$ \\
    - $\predlblnm'$ updates $\predlblnm$ such that $\forall p, \predlblnm'(n, p) = \maybe$ \\
    - $\edgesnm'$ updates $\edgesnm$ such that $\edgesnm'(n,f,m) = \false$, and $\edgesnm'(m,f,n) = \false$ for all fields $f$ and nodes $m \neq n$ \\
    - $\sigma'$ updates $\sigma$ such that $\sigma'(n) = \true$
  \item \textbf{COPY} ($v1 := v2$): \\
    - $\nodesnm' = \nodesnm$ \\
    - $\varlblnm'$ updates $\varlblnm$ such that $\forall n \in \nodesnm, \varlblnm'(v1, n) = \varlblnm(v2, n)$ \\
    - $\predlblnm' = \predlblnm$ \\
    - $\edgesnm' = \edgesnm$ \\
    - $\sigma' = \sigma$
  \item \textbf{LOAD} ($v1 := v2 \select f$): \\
    - $\nodesnm' = \nodesnm$ \\
    - $\varlblnm'$ updates $\varlblnm$ as follows: \\
      \hspace*{1em} Let $S = \{n \in \nodesnm : \varlblnm(n, v2) = \true \vee \varlblnm(n, v2) = \maybe\}$ \\
      \hspace*{1em} Let $T = \{n \in \nodesnm : \exists s \in S \cdot \edgesnm(s, f, n) = \true \vee \edgesnm(s, f, n) = \maybe\}$ \\
      \hspace*{1em} if $T = \{t\}$ (singleton), then $\varlblnm'(t, v1) = \true$, otherwise $\forall t \in T, \varlblnm'(t, v1) = \maybe$ \\
    - $\predlblnm' = \predlblnm$ \\
    - $\edgesnm' = \edgesnm$ \\
    - $\sigma' = \sigma$
  \item \textbf{STORE} ($v1 \select f := v2$): \\
    - $\nodesnm' = \nodesnm$ \\
    - $\varlblnm' = \varlblnm$ \\
    - $\predlblnm' = \predlblnm$ \\
    - $\edgesnm'$ updates $\edgesnm$ as follows: \\
      \hspace*{1em} Let $S = \{n \in \nodesnm : \varlblnm(n, v1) = \true \vee \varlblnm(n, v1) = \maybe\}$ \\
      \hspace*{1em} Let $T = \{n \in \nodesnm : \varlblnm(n, v2) = \true \vee \varlblnm(n, v2) = \maybe\}$ \\
      \hspace*{1em} $\forall s \in S, t \in T, \edgesnm'(s,f,t) = \maybe$ (and $\true$ if both $S$ and $T$ are singletons) \\
    - $\sigma' = \sigma$
  \item \textbf{PREDICATE} ($\predinstr$): \\
    - $\nodesnm' = \nodesnm$ \\
    - $\varlblnm' = \varlblnm$ \\
    - $\forall n \in \nodesnm, p \in \predvars, \predlblnm'(n,p) = post(p, \predlblnm(n,p), \predinstr)$, where $post$ is a postcondition operator for three-valued predicates \\
    - $\edgesnm' = \edgesnm$ \\
    - $\sigma' = \sigma$
\end{itemize}

\section{\verifier}
This section describes our algorithm for building a complete, safe, well-labeled unwinding of a heap-manipulating program. Our algorithm builds on top of the \impact algorithm defined in \autoref{sec:impact-algorithm}. Our algorithm may not terminate if the program is safe. If the program is unsafe, and our Oracle can help find the right interpolant, then our algorithm will terminate. A non-deterministic procedure with three basic steps is outlined here. The three steps are

\begin{itemize}
  \item \expandp, which generates the successors of a leaf vertex (\autoref{alg:heap-expand})
  \item \refinep, which refines the labels along a path, labeling an error vertex $\false$ (\autoref{alg:heap-refine})
  \item \coverp, which expands the covering relation (\autoref{alg:heap-cover})
\end{itemize}

Each of the three steps preserves well-labeledness of the unwinding. When none of the three steps can produce any change, the unwinding is both safe and complete, so we know that the original program is safe.

In addition to the three steps above, there are two main procedures that are needed by \refinep which allow it to interact with the Oracle and generate interpolants for the verification. The procedures are

\begin{itemize}
  \item \seplearner, which \refinep relies on to provide a valid interpolant for an error location (\autoref{alg:interplearner})
  \item \newcandidate, which is used by \seplearner to interact with the Oracle, and query for a heap pattern given positive and negative concrete heaps (\autoref{alg:newcandidate})
\end{itemize}

\subsection{Algorithm Description}
We now briefly explain how the main procedures for \verifier work. The outline is very similar to that of the \impact algorithm defined in \autoref{sec:impact-algorithm}, but our modifications make it possible to use heap patterns in place of simple FOL formulas.

\expandp, formally outlined in \autoref{alg:heap-expand}, explores new actions for an uncovered leaf. An uncovered leaf (described in \autoref{defn:labeled-prog-unwinding}) is intuitively one for which all possible successor states have not been explored yet. If the vertex $v \in V$ supplied to \expandp is an uncovered leaf, then for each possible action $T$ at the program location $M_v(v)$, a new vertex $w$ is added to the unwinding tree (\autoref{line:expandp-add-new-vertex}). This is normally done when a leaf is such that it cannot be covered by any other vertex in the tree, and thus needs further state space exploration. Notice that this is identical to \impact, but with they key difference that a new vertex in the unwinding is initialized with the universal heap $1_D$ instead of $\true$ (\autoref{line:expandp-universal-heap}).

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procexpand}{EXPANDP}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procexpand{$v \in V$}:}{
    %
    \If{$v$ is an uncovered leaf}{
        \ForEach{action $(M_v(v),T,m) \in \Delta$}{
        add a new vertex $w$ to $V$ and a new edge $(v,w)$ to $E$; \label{line:expandp-add-new-vertex} \\
        set $M_v(w) \leftarrow m$ and $\psi(w) \leftarrow 1_D$; \label{line:expandp-universal-heap} \\
        set $M_e(v,w) \leftarrow T$;
      }
    }
  }
  \caption{$\expandp$: takes as input a vertex $v \in V$ and expands the control flow graph based on all actions available at that vertex.}
  \label{alg:heap-expand}
\end{algorithm}

\refinep is the procedure that generates the interpolant, and can potentially mark an error vertex unreachable. Firstly, we note that if \refinep succeeds, then $\phi(v)$ must be $0_D$, the empty heap pattern (since $\hat{A}_n$ is always $0_D$). Thus, to make the unwinding safe, we have to only apply \refinep to every error vertex (\autoref{line:refinep-only-error-vertex}) that hasn't yet been marked $0_D$. For such an error vertex $v$, \refinep makes a call to \seplearner (\autoref{alg:interplearner}) to find an interpolant for the path from root to error vertex (\autoref{line:refinep-query-decision-procedure}). If an interpolant is not found it could mean one of two things
\begin{enumerate}
  \item The program has a bug, and the error vertex is actually reachable
  \item The interaction with the Oracle did not result in an interpolant being found
\end{enumerate}
Since our Oracle cannot be guaranteed to definitely provide an interpolant, at this point, we quit \refinep and try again later when more vertices have been labeled with heap patterns (\autoref{line:refinep-program-unsafe}). If an interpolant is found, then it is used to strengthen the predicate labelings at the vertices along the path $\pi$. In particular, if the interpolant formula at a vertex $v_i$ is not entailed by the current heap pattern label at $v_i$ (\autoref{line:refinep-not-subsumed}), then the current label can be strengthened. Note that if this happens, then the stronger label at $v_i$ may possibly lead it to stop covering some of the vertices it previously covered. This is taken into account by removing all pairs $(\cdot, v_i)$ in the covering relation $\rhd$ (\autoref{line:refinep-remove-covering-relations}).


\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procrefine}{REFINEP}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procrefine{$v \in V$}:}{
    %
    \If{$M_v(v) = l_f$ and $\psi(v) \not\equiv 0_D$}{
      \label{line:refinep-only-error-vertex}
      let $\pi = (v_0, T_0, v_1) \cdots (v_{n-1}, T_{n-1}, v_n)$ be the unique path from $\epsilon$ to $v$ \\
      let $\hat{A_0},\cdots,\hat{A_n}$ = \seplearner($\mathcal{U}(\pi)$) \label{line:refinep-query-decision-procedure} \\
      \eIf{$\hat{A_0},\cdots,\hat{A_n}$ is a valid interpolant}{
          \For{$i = 0 \cdots n$}{
          let $\phi = \hat{A}_i^{\langle -i \rangle}$ \\
          \If{$\psi(v_i) \nvDash \phi$}{
            \label{line:refinep-not-subsumed}
            remove all pairs $(\cdot, v_i)$ from $\rhd$; \label{line:refinep-remove-covering-relations} \\
            set $\psi(v_i) \leftarrow \psi(v_i) \land \phi$;
          }
        }
      }
      {
        abort (retry later) \label{line:refinep-program-unsafe}
      }
    }
  }
  \caption{$\refinep$: takes as input a vertex $v \in V$ at an error location and tags the path from root to $v$ with invariants. \seplearner (\autoref{alg:interplearner}) is the procedure that queries the Oracle and provides an interpolant that can be used in \refinep. Notice that if the interpolant cannot be found, we might have to try later after the unwinding tree has changed.}
  \label{alg:heap-refine}
\end{algorithm}

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{proccover}{COVER}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\proccover{$v, w \in V$}:}{
    %
    \If{$v$ is uncovered and $M_v(v) = M_v(w)$ and $v \nvDash w$}{
      \If{$\psi(v) \vDash \psi(w)$}{
        add $(v,w)$ to $\rhd$; \\
        delete all $(x,y) \in \rhd$, s.t. $v \sqsubseteq y$;
      }
    }
  }
  \caption{$\coverp$: takes as input vertices $v, w \in V$ and attempts to cover $v$ with $w$.}
  \label{alg:heap-cover}
\end{algorithm}

\section{Learning Invariants from Positive and Negative Examples}

We note in \autoref{alg:heap-refine} the procedure \seplearner is used, which is the core component of making \impact work for heap-manipulating programs. In this section, we describe this algorithm.

We defined the notion of interpolants in \autoref{sec:interpolants-from-proofs}, and the same applies to \seplearner, which is described in \autoref{alg:interplearner}.

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procinterplearner}{INTERPLEARNER}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procinterplearner{$\mathcal{U}(\pi)$}:}{
    %
    Let $\pi = (l_0, T_0, l_1)(l_1, T_1, l_2) \cdots (l_{n-1}, T_{n-1}, l_n)$ \\
    Set $\hat{A_i} = 1_D, 0 \leq i < n, \hat{A_n} = 0_D$ \\
    Set $H_i^{+} = \{\}, 0 \leq i \leq n$ \\
    Set $H_i^{-} = \{\}, 0 \leq i \leq n$ \\

    \While{$\neg$\isinterpolant($\hat{A},\mathcal{U}(\pi)$)}{
      pick $i \in \{1,2,\cdots, n-1\}$
      $\hat{A_i} = \newcandidate(l_i, \hat{A}, H^{+}, H^{-}, \psi, \mathcal{U}(\pi))$
    }
    \Return $\hat{A_0}, \hat{A_1}, \cdots, \hat{A_n}$
  }
  \caption{$\seplearner$: takes as input an unfolding $\mathcal{U}(\pi)$ of path $\pi$ and attempts to find an invariant for it.}
  \label{alg:interplearner}
\end{algorithm}

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procisinterpolant}{ISINTERPOLANT}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procisinterpolant{$\hat{A}, \mathcal{U}(\pi)$}:}{
    %
    \If{$\hat{A_0}, \hat{A_1}, \cdots, \hat{A_n}$ is an interpolant for $\mathcal{U}(\pi)$}{
      \Return $\true$
    }
    \Return $\false$
  }
  \caption{$\isinterpolant$: takes as input candidates $\hat{A}$ and unfolding $\mathcal{U}(\pi)$ of path $\pi$, and checks if $\hat{A}$ represents an interpolant for the unfolding.}
  \label{alg:isinterpolant}
\end{algorithm}

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procnewcandidate}{NEWCANDIDATE}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procnewcandidate{$l_i, \hat{A}, H^{+}, H^{-}, \psi, \mathcal{U}(\pi)$}:}{
    %
    Let $\pi = (l_0, T_0, l_1)(l_1, T_1, l_2) \cdots (l_{n-1}, T_{n-1}, l_n)$ \\
    Set $S = \post^{*}(1_D, \pi_{0,i})$ \\
    Set $C = 1_D$ \\
    \While{$\true$}{
      $C = \mathcal{O}(H_i^{+}, H_i^{-})$ \\
      \If{$S \not \entails C$}{
        $H_i^{+} = \{h\} \cup H_i^{+}$ where $h \in S, h \not \in C$ \\
        continue
      }
      \If{$\post(C, T_i) \not \entails \hat{A}_{i+1}$}{
        $\exists h \cdot h \matchedby C \wedge \post(h, T_i) \not \matchedby \hat{A}_{i+1}$ \\
        $H_i^{-} = \{h\} \cup H_i^{-}$ \\
        continue
      }
      break
    }
    \Return $C$
  }
  \caption{$\newcandidate$: takes as input a program location $l_i$, current set of candidates $\hat{A}$, sets of positive and negative examples for each location ($H^{+}, H^{-}$ respectively), map $\psi$, and unfolding $\mathcal{U}(\pi)$ of path $\pi$, and interacts with the Oracle $\mathcal{O}$ to find a new candidate for $l_i$.}
  \label{alg:newcandidate}
\end{algorithm}

While \seplearner is the higher level procedure to find an interpolant, it uses a sub-procedure called \newcandidate as a feedback loop with the Oracle, to accept candidate heap patterns that can be used to construct an interpolant.

\section*{Summary}
This chapter presented \verifier, our algorithm for verifying heap-manipulating programs. \verifier uses an Oracle to perform the interpolation step, which helps in learning heap patterns from positive and negative concrete examples. The next chapter describes the implementation of an interface for one such Oracle - a human user.
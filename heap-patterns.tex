% Describe heap patterns

\section{Heap Patterns}
\label{sec:heap-patterns}
%
In this section, we define a standard language that performs low-level
memory operations to update linked data structures
(\autoref{sec:lang}).
%
We then review definitions of three-valued structures introduced in
previous work~\cite{sagiv02}, which we use to formulate patterns over
program heaps (\autoref{sec:patterns}).

% Define a toy imperative language.
\subsection{Language Definition}
\label{sec:lang}
%
In this section, we define the syntax (\autoref{sec:syntax}) and
semantics (\autoref{sec:semantics}) of our subject language \lang.

% Define the language syntax.
\subsubsection{Syntax}
\label{sec:syntax}
% Define the syntax of a program.
\begin{figure}
  \centering
  \begin{align}
    % A program is a sequence of statements.
    \lang \assign & (\locs: \instrs)^{*} \label{line:prog} \\
    % A statement is a predicate instruction or a heap instruction.
    \instrs \assign & \predinstr\ |\ \heapinstr \label{line:instrs} \\
    % A predicate instruction:
    \predinstr \assign &
    % updates predicates according to an operation.
    \predvars \assign \predvars\ \predops\ \predvars
    %
    \label{line:bool-op} \\
    % or tests equalities of heap variables,
    |\ & \predvars \assign (\heapvars = \heapvars)
    %
    \label{line:test-eq} \\
    % or branches.
    |\ & \branch\ \predvars, \locs, \locs \label{line:branch} \\
    % A heap instruction: allocates a new cell:
    \heapinstr \assign & \heapvars \assign \alloc()
    %
    \label{line:alloc} \\
    % or a copy,
    |\ & \heapvars \assign \heapvars \label{line:copy} \\
    % or a load,
    |\ & \heapvars \assign \heapvars \select \fields
    %
    \label{line:load} \\
    % or a store.
    |\ & \heapvars \select \fields \assign \heapvars
    %
    \label{line:store}
  \end{align}
  \caption{Syntax of heap-updating programs, $\lang$.
    %
    The spaces of control locations, predicate variables, heap
    variables, and fields are denoted $\locs$, $\predvars$,
    $\heapvars$, and $\fields$, respectively.
  }
  \label{fig:syntax}
\end{figure}

% Walk through the full syntax of programs.
A \lang program is a sequence of instructions that operate on a fixed
set of predicate variables and pointers to heap objects.
%
The syntax of \lang is given in \autoref{fig:syntax} for fixed finite
sets of control locations $\locs$, predicate variables $\predvars$,
heap variables $\heapvars$, and heap fields $\fields$.
%
A program is a sequence of instruction, each labeled with a control
location (\autoref{line:prog}).
%
An instruction either updates the program's predicate variables or
heap variables (\autoref{line:instrs}).
%
An instruction that updates predicate variable either stores in a
predicate variable the result of a Boolean operation
(\autoref{line:bool-op}),
%
an equality test on heap cells (\autoref{line:test-eq}),
%
or branches control based on the value in a predicate variable
(\autoref{line:branch}).
%
An instruction that updates heap variables either allocates a new heap
cell (\autoref{line:alloc}),
%
copies the heap cell from one pointer variable to another
(\autoref{line:copy}),
%
loads a heap cell into a pointer variable (\autoref{line:load}),
%
or stores a heap cell as a child of a cell in a pointer variable
(\autoref{line:store}).

% Define the control-flow graph.
For each program $P \in \lang$, the control-flow graph of $P$,
$\cfg_P \subseteq \locs \times \instrs \times \locs$, is defined in
the standard way.

% describe the standard Impact algorithm
% \section{Impact Algorithm}
\label{ch:impact-algorithm}
%

This section describes a semi-algorithm from \cite{mcmillan06}, for building a complete, safe, well-labeled unwinding of a program. The algorithm terminates if the program is unsafe, but may not terminate if it is safe (which is expected, since program safety is undecidable). A non-deterministic procedure with three basic steps is outlined here. The three steps are

\begin{itemize}
  \item \expand, which generates the successors of a leaf vertex (\autoref{alg:expand})
  \item \refine, which refines the labels along a path, labeling an error vertex $\false$ (\autoref{alg:refine})
  \item \cover, which expands the covering relation (\autoref{alg:cover})
\end{itemize}

The interpoland in \refine can be generated from a refutation of $\mathcal{U}(\pi)$ by the method of \cite{mcmillan05}. Each of the three steps preserves well-labeledness of the unwinding. To make the unwinding safe, we have to only apply \refine to every error vertex. When none of the three steps can produce any change, the unwinding is both safe and complete, so we know that the original program is safe.
To build a well-labeled unwinding, a strategy is required, for applying the three unwinding rules. The most difficult question is when to apply \cover. Covering one vertex can result in uncovering others. Thurs, applying \cover non-deterministically may not terminate.

\section{Termination}
TODO: Need to add brief background from \cite{mcmillan06}.

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procexpand}{EXPAND}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procexpand{$v \in V$}:}{
    %
    \If{$v$ is an uncovered leaf}{
        \ForEach{action $(M_v(v),T,m) \in \Delta$}{
        add a new vertex $w$ to $V$ and a new edge $(v,w)$ to $E$; \\
        set $M_v(w) \leftarrow m$ and $\psi(w) \leftarrow \true$; \\
        set $M_e(v,w) \leftarrow T$;
      }
    }
  }
  \caption{$\expand$: takes as input a vertex $v \in V$ and expands the control flow graph based on all actions available at that vertex.}
  \label{alg:expand}
\end{algorithm}

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{procrefine}{REFINE}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\procrefine{$v \in V$}:}{
    %
    \If{$M_v(v) = l_f$ and $\psi(v) \not\equiv \false$}{
      let $\pi = (v_0, T_0, v_1) \cdots (v_{n-1}, T_{n-1}, v_n)$ be the unique path from $\epsilon$ to $v$ \\
      \eIf{$\mathcal{U}(\pi)$ has an interpolant $\hat{A_0},\cdots,\hat{A_n}$}{
          \For{$i = 0 \cdots n$}{
          let $\phi = \hat{A}_i^{\langle -i \rangle}$ \\
          \If{$\psi(v_i) \nvDash \phi$}{
            remove all pairs $(\cdot, v_i)$ from $\rhd$; \\
            set $\psi(v_i) \leftarrow \psi(v_i) \land \phi$;
          }
        }
      }
      {
        abort (program is unsafe)
      }
    }
  }
  \caption{$\refine$: takes as input a vertex $v \in V$ at an error location and tags the path from root to $v$ with invariants.}
  \label{alg:refine}
\end{algorithm}

\begin{algorithm}[ht]
  % Declare functions
  \SetKwFunction{proccover}{COVER}

  % Declare sub-program markers.
  \SetKwProg{myproc}{Procedure}{}{}

  % expand
  \myproc{\proccover{$v, w \in V$}:}{
    %
    \If{$v$ is uncovered and $M_v(v) = M_v(w)$ and $v \nvDash w$}{
      \If{$\psi(v) \vDash \psi(w)$}{
        add $(v,w)$ to $\rhd$; \\
        delete all $(x,y) \in \rhd$, s.t. $v \sqsubseteq y$;
      }
    }
  }
  \caption{$\cover$: takes as input vertices $v, w \in V$ and attempts to cover $v$ with $w$.}
  \label{alg:cover}
\end{algorithm}
\label{ch:intro}

In the context of hardware and software systems, formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification or property, using formal methods of mathematics. Formal verification can be helpful in proving the correctness of systems such as: cryptographic protocols, combinational circuits, digital circuits with internal memory, and software expressed as source code. Verification uses a wide variety of techniques, in particular logic calculi, formal languages, automata theory, and program semantics, but also type systems and algebraic data types to problems in software and hardware specification and verification.

The verification of these systems is done by providing a formal proof on an abstract mathematical model of the system, the correspondence between the mathematical model and the nature of the system being otherwise known by construction. Examples of mathematical objects often used to model systems are: finite state machines, labeled transition systems, Petri nets, vector addition systems, timed automata, hybrid automata, process algebra, formal semantics of programming languages such as operational semantics, denotational semantics, axiomatic semantics and Hoare logic.

\section{Software Verification}

The goal of software verification is to assure that software fully satisfies all the expected requirements. Software verification has been successful for improving the quality of computer programs. Several fundamental concepts were invented in the last decade which made it possible to scale the technology from tiny examples to real programs. Predicate abstraction \cite{ball01} with counterexample guided abstraction refinement (CEGAR) \cite{clarke03} and lazy abstraction \cite{henzinger02} is one such set of techniques. Lazy abstraction with Interpolants \cite{mcmillan06} is another approach. Several of these approaches are flexible and can be specialized or extended for sub-classes of programs or specifications.

\section{Verifying Heap-manipulating Programs}
A heap-manipulating program is one that updates heap memory using low-level memory operations (such as allocating or deallocating memory, or modifying pointers). Dealing with programs with pointers and dynamic linked data structures is among the most challenging tasks of formal analysis and verification due to a need to deal with infinite sets of reachable program configurations having the form of complex graphs. This task becomes even more complicated when considering low-level memory operations such as pointer arithmetic, safe usage of pointers with invalid targets, block operations with memory, reinterpretation of the memory contents, or address alignment. Despite the rapid progress in the area of formal program analysis and verification, fully automated approaches capable of efficiently handling sufficiently general classes of dynamic
linked data structures in the form used in low-level code are still missing.

\section{Oracle-guided Heap Interpolant Synthesis}
Traditional formal methods do not scale to the size of software found in modern computer systems. This is further exacerbated in the case of heap-manipulating programs. Verification also currently requires highly specialized engineers with deep knowledge of software technology and mathematical theorem-proving techniques. These constraints make current formal verification techniques expensive and time-consuming.





The field of electronic design automation (EDA), in general, and
formal verification, in particular, has relentlessly pushed for automation.
For several problems, this is indeed the right strategy.
But for many problems human insight and involvement remain invaluable.
Consider, for example, the process of verifying a design.
First of all, one needs to write a specification, typically in the form
of properties (assertions) or a reference model. Second, one must
create an environment model, typically in the form of constraints
on the inputs or a state machine description. Next, one runs the
verifier, such as a model checker, which is usually thought of as a
“push-button” technique. While this is largely true, human insight
is not entirely absent; e.g., one might need to supply hints to the
verifier in the form of suitable abstraction techniques or (templates
for) inductive invariants. If the verifier returns with a counterexample
trace, one must debug the design by localizing the cause of
error in time (relevant part of the trace) and space (relevant part of
the design). Finally, the process of repairing the design to eliminate
the bug is also one that needs human input. To summarize, even
after decades of work on automating the verification process, we
continue to need human insight in a variety of tasks, including writing
specifications, creating models, guiding the verification engine,
debugging and error localization, and repair.
This paper takes the position that while we cannot completely
remove human insight from the verification process, we can change
the way humans provide insight to the verifier. Today, such input
typically comes from expert verification engineers, trained in the
tools of their field. But such experts are few and expensive. And
even experts have a hard time answering questions such as: When
are we done verifying? Have we written enough properties? Where
is the bug? And so on. We contend that the experts and automated
tools can be assisted in the verification process by a large crowd
of non-expert humans performing simple and repetitive tasks. Each
task involves a pattern recognition or other cognitive operations that
humans are typically good at. The main technical challenges are
to identify steps in the verification process where human insight is
critical, find ways to transform these steps into tasks that non-expert
humans can perform, and combine the results to resolve those steps
in the verification process. As preliminary evidence to show that
these challenges can be met, we present a system called CrowdMine
for finding specifications from traces based on pattern recognition
by humans.
The idea of tapping into a crowd of humans to assist in a computational
task is not new. Crowdsourcing is the act of taking a
job traditionally performed by a designated agent (usually an employee)
and outsourcing it to an undefined, generally large group
of people in the form of an open call [7]. Human computation is a
paradigm for utilizing human processing power to solve problems
that computers cannot yet solve [15]. (See Quinn and Bederson [12]
for a more detailed description of these and related terms.) Our proposal
is to use a combination of crowdsourcing and human computation
to improve the state-of-the-art in verification. The availability
of tools like Amazon’s Mechanical Turk [1] and TurKit [10] make
such a combination easier to deploy today.





The rest of this thesis is organized as follows. \autoref{ch:overview} gives a high-level overview of our approach with an example, laying an intuitive foundation for the formal description that follows. \autoref{ch:background} presents an extensive summary of the framework for finding inductive invariants from interpolants, and the Impact algorithm from \cite{mcmillan06}. \autoref{ch:heap-patterns} describes our formalism for representing heaps and heap patterns, and modeling heap-manipulating programs for verification. \autoref{ch:heap-impact-algorithm} gives a detailed description of our main algorithm, as an extension of the Impact algorithm. Our algorithm requires an Oracle, which we have chosen to be a human user, and \autoref{ch:interface-oracle} presents our user interface with some analysis. \autoref{ch:conclusion} discusses related work, and concludes.

\subsubsection{External Collaboration}
The work in this thesis is part of the collaboration with Somesh Jha\footnote{University of Wisconsin, Madison}, William Harris\footnote{Georgia Institute of Technology}, and Drew Davidson\footnote{University of Wisconsin, Madison}. Somesh and Bill were immensely insightful in helping narrow down the problem domain, while providing constant guidance. Drew was very helpful with implementing our ideas. This work would not have been possible without our several regular weekly discussions.


\label{ch:intro}

In the context of hardware and software systems, formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification or property, using formal methods of mathematics. Formal verification can be helpful in proving the correctness of systems such as: cryptographic protocols, combinational circuits, digital circuits with internal memory, and software expressed as source code. Verification uses a wide variety of techniques, in particular logic calculi, formal languages, automata theory, and program semantics, but also type systems and algebraic data types to problems in software and hardware specification and verification.

The verification of these systems is done by providing a formal proof on an abstract mathematical model of the system, the correspondence between the mathematical model and the nature of the system being otherwise known by construction. Examples of mathematical objects often used to model systems are: finite state machines, labeled transition systems, Petri nets, vector addition systems, timed automata, hybrid automata, process algebra, formal semantics of programming languages such as operational semantics, denotational semantics, axiomatic semantics and Hoare logic.

\section{Software Verification}

The goal of software verification is to assure that software fully satisfies all the expected requirements. Software verification has been successful for improving the quality of computer programs. Several fundamental concepts were invented in the last decade which made it possible to scale the technology from tiny examples to real programs. Predicate abstraction \cite{ball01} with counterexample guided abstraction refinement (CEGAR) \cite{clarke03} and lazy abstraction \cite{henzinger02} is one such set of techniques. Lazy abstraction with Interpolants \cite{mcmillan06} is another approach. Several of these approaches are flexible and can be specialized or extended for sub-classes of programs or specifications.

\section{Verifying Heap-manipulating Programs}
A heap-manipulating program is one that updates heap memory using low-level memory operations (such as allocating or deallocating memory, or modifying pointers). Dealing with programs with pointers and dynamic linked data structures is among the most challenging tasks of formal analysis and verification due to a need to deal with infinite sets of reachable program configurations having the form of complex graphs. This task becomes even more complicated when considering low-level memory operations such as pointer arithmetic, safe usage of pointers with invalid targets, block operations with memory, reinterpretation of the memory contents, or address alignment. Despite the rapid progress in the area of formal program analysis and verification, fully automated approaches capable of efficiently handling sufficiently general classes of dynamic
linked data structures in the form used in low-level code are still missing.

\section{Oracle-guided Heap Interpolant Synthesis}
Traditional formal methods do not scale to the size of software found in modern computer systems. This is further exacerbated in the case of heap-manipulating programs. Verification also currently requires highly specialized engineers with deep knowledge of software technology and mathematical theorem-proving techniques. These constraints make current formal verification techniques expensive and time-consuming.
